    L a b   1 0 :  L i m i t a t i o n s  o f  C om p u t e r  A r i t h m e t i c   

*Date*: Nov 11, 2021

This document first describes the aims of this lab.  It then provides
necessary background.  It then describes the exercises which need to be
performed.


			Aims
			====

The aim of this lab is to introduce you to the limitations of computer
arithmetic.  After completing this lab, you should be familiar with the
following topics:

  + The approximation of integer aritmetic by modular arithmetic.

  + Determining units in the last place for C `float`'s.

  + Non-associativity of floating point arithmetic.

  + .<https://en.wikipedia.org/wiki/Type_punning> "Type-punning" using
    C `union`'s.

    	       	       	 Background
			 ==========

There are an infinite number of numbers.  But computers (even with today's
large memories) are finite.  Hence it is impossible for any computer to
represent all numbers and the numbers representable within computers are
only a subset of the infinite set of all numbers.

Many programming languages provide two types of number representations:

  : *Fixed-point representations*:
     This representation has a fixed maximum number of digits before and
     after the radix point.  It has good precision but a limited range.

     An example of a fixed-point representation are integers of various
     lengths where number of digits after the radix point is 0.

  : *Floating-point representations*:
     The position of the radix point is not fixed but is specified
     by some kind of exponent (similar to "scientific notation" for
     decimal numbers).  This representation allows a wider range but
     at the cost of a loss in precision.

       	    	  	   Exercises
			   =========

			Starting up
			-----------

Follow the .<../working/working.html> "provided directions" for
starting up this lab in a new git `lab10` branch and a new
`submit/lab10` directory.  You should have copied over
the contents of `~/cs220/labs/lab10/exercises` over to your
directory.

You may need to evaluate the powers-of-2, so it may be a good idea to
setup some kind of calculator to do so.  A possible calculator is an
interactive python shell started using `python` in a different
terminal tab.  Type `2**31` into it to evaluate 2-to-the-power-of-31.

			Exercise 1: Unsigned Integer Overflow
			-------------------------------------

Change over to the .<./exercises/uints> uints directory and look at the
.<./exercises/uints/uints.c> uints.c program.  Once you have looked at the
source code, build the `uints` executable by typing `make`.  Run the
program by typing `./uints`.

Type in interesting numbers which are on the 16-bit and 32-bit boundaries
like `65535`, `65536`, `65537` and `4294967295`, `4294967296` and
`4294967297`, and observe the results.  Notice the silent overflow.

Terminate the program by typing `^D`.

			Exercise 2: Signed Integer Overflow
			-----------------------------------

Change over to the .<./exercises/ints> ints directory and look at the
.<./exercises/ints/ints.c> ints.c program.  Once you have looked at the
source code, build the `ints` executable by typing `make`.  Run the
program by typing `./ints`.

Type in interesting numbers which are on the 16-bit and 32-bit boundaries
like `32767`, `32768`, `32769` and `65535`, `2147483647`, `2147483648`,
`2147483649`, `4294967295` and observe the results.  Notice the silent
overflow with changing sign.

Terminate the program by typing `^D`. 



    	     	 Exercise 3: An Integer equal to Its Negation
		 --------------------------------------------

Change into the .<./exercises/negeq> negeq directory and type `make`.  Then run
the program `./negeq`.  This program requires you to input an `int`
which is equal to its own negation.  Like the previous exercise, the
program takes its input in hex (without any leading `0x`).  You should
provide some integer `n` in hex such that the program outputs `N ==
-N` where `N` is the decimal representation of hex integer `n`.

Consider the previous exercises to identify this value (Hint: recall the
asymmetry of 2's complement).

	     	 Exercise 4: Infinite Precision Integers
		 ---------------------------------------

As the previous exercises illustrate, in C integers are represented with a
small precision like 16 or 64 bits.  Newer languages like Python, Ruby,
Perl6 allow integers with precision limited only by available memory.

For example, fire up an interactive python using `python` and type
`10**1000 - 1`.  You should see output containing quite a few lines of
`9`'s.  It's kind of neat that such examples work (some languages like
Scheme even allow rational numbers where numbers are represented as
fractions with fraction arithmetic).

However, now within `python`, type `10**1000 - 1.0`.  You should get back
a message which should reveal to you that the representation of
numbers within computers is only an approximation of numbers.

	     	  Exercise 5: 0.1 cannot be represented
		  -------------------------------------

Recall from class that the floating point representation commonly used with
present day computers is a binary representation.  That means that numbers
which can be represented by fractions with denominators which are a
power-of-2 can be represented exactly but other numbers cannot.  For
example, 0.1 which is 1/10 cannot be represented exactly and this exercise
illustrates this problem.

Change over to the .<./exercises/inexact> inexact directory and look at the code
in .<./exercises/inexact/0.1.c> 0.1.c You should see that all it is doing is
summing up 0.1 10 times, printing out the resulting sum as well as
checking whether the sum is equal to 1.

Build and run the program and observe the result.


	     	  Exercise 6: A Number Not Equal To Itself 
		  ----------------------------------------

Change over to the .<exercises/nan> nan directory.  The program in
.<./exercises/nan/nan.c> nan.c requires you to enter a number, divides
that number by itself to get `x` and then loops as long as `x != x`.
Compile and run the program and then provide an input to force the
program into an infinite loop.  Hint: The number `NaN` is not equal to
itself, hence if your input sets `x` to `NaN` the program will loop.

Once you are successful, terminate the infinite loop by typing a `control-C`.

     	        Exercise 7: Unit in Last Position
		---------------------------------

This exercise illustrates that the value of the "unit in last place" of a
floating point number increases dramatically with the value being
represented.  

Change into the .<./exercises/ulp> ulp directory and build the `ulp`
program by typing `make`.  Then run `./ulp`, it should output a usage
message.  Run it as `./ulp verbose` and it should produce a dump on
standard output of the value of a single-precision `float` number
being represented along with the value of the unit in the last place
of the number.  Note that as the magnitude of the values increase, the
ULP rapidly goes above 1.  That means those values cannot be
distinguished even if they differ by 1.

It may be a good idea to look at the ULP distribution on a graph.  Run
`./ulp data >ulp.data` which dumps out the ULP distribution in a format
acceptable to the `gnuplot` plotting program.  Display the graph using
`gnuplot -p ulp.gp`.  Unfortunately, because of the linear scale, most of
the values are concentrated near the origin.

If you are not using a GUI interface on `remote.cs` `gnuplot` will
refuse to run as it is looking for a graphics terminal.  You can get
an extremely crude plot within your terminal by adding the line:

```
set terminal dumb;
```

at the start of the `ulp.gp` file.

This cries out for the use of logarithmic scales.  Run `./ulp lg-data
>ulp-lg.data` which dumps out the log (base-2) of the data into
`ulp-lg.data`.  Now display the graph using `gnuplot -p ulp-lg.gp`.
This should produce a much cleaner plot.  The workaround which was
described above can be used to get the output on a dumb terminal.

It is worth understanding how the .<./exercises/ulp/ulp.c> ulp program works.
The key to its working is the `FloatInt` `union`.  A `union` is similar to
a `struct` except that its members occupy the same memory location.  Hence
it is possible to use `union`'s to get at the representation of types as is
done here.

The floating point member of the union is assigned a power-of-2.  That means
that the normalized floating point mantissa will be all zeros.  Thus by
adding 1 to the integer member of the union (recollect that the integer and
float members occupy the same memory), we are incrementing the ULP of the
floating point member.  Hence the value of the ULP is the value of the
incremented member minus the original value.

	    	   Exercise 8: Different Numbers are not Distinguishable
		   =====================================================

Two floating point numbers which differ by less than the ULP for their
values cannot be distinguished.

Change into the .<exercises/loop> loop directory and build and compile
.<./exercises/loop/loop.c> loop.c.  Look at the code in
.<./exercises/loop/loop.c> loop.c, and based on the results of the previous
exercise, provide a minimal power-of-2 input which causes it to go
into an infinite loop.


      	  	  	    References
			    ==========


Text, Ch. 2.

Joshua Bloch and Neal Gafter, "Java Puzzlers: Traps, Pitfalls and Corner
Cases", Addison-Wesley, 2005.  Source of some of the exercises.
